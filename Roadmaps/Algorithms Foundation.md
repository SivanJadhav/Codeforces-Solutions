# ğŸš€ Algorithms Foundation

## ğŸ”° Phase 1: Pure Logic & Problem-Solving (No Algorithms Yet)

**Goal:** Develop pure problem-solving ability before touching any algorithms.

### ğŸ’¡ Theory (Minimal)

- How to bruteforce properly (trying all possibilities smartly)
- Recognizing patterns & breaking problems into cases

### âœ… Problems to Solve:

- Two knights on a chessboard (count valid placements)
- Find the second smallest number in an array (without sorting)
- Find the most frequent number in an array (without sorting or maps)
- Reverse an integer without using strings
- Check if two strings are anagrams (without sorting or extra space)
- Find the first missing positive integer in an unsorted array

---

## ğŸ“ Phase 2: Sorting & Searching (First Real Algorithms)

**Goal:** Master sorting and binary searchâ€”your first algorithmic tools.

### ğŸ’¡ Theory (From Problems)

- Sorting logic: Why O(n log n) is the best we can do
- Binary search thinking: Searching not just for numbers but conditions

### âœ… Problems to Solve:

- Sorting a large array & finding duplicates (but without extra memory)
- Find the two numbers in an array that sum to x (sorted & unsorted cases)
- Search a number in a rotated sorted array
- Find the smallest missing number in a sorted array (without scanning linearly)
- Find the square root of a number without `sqrt()` (binary search on answer)

ğŸš€ **Hard Enforcer:** "Painterâ€™s Partition Problem"

---

## âš¡ Phase 3: Two Pointers & Sliding Window

**Goal:** Learn pointer-based problem solving to replace naive loops.

### ğŸ’¡ Theory (From Problems)

- When to use two pointers instead of nested loops
- Sliding window to optimize sum & substring problems

### âœ… Problems to Solve:

- Find a pair in an array that sums to x (two-pointer approach)
- Longest substring without repeating characters (sliding window)
- Find the smallest subarray with sum â‰¥ S (sliding window)
- Sort an array of only 0s, 1s, and 2s in one pass
- Merge two sorted arrays without extra space

ğŸš€ **Hard Enforcer:** "Trapping Rain Water"

---

## ğŸ”¥ Phase 4: Greedy Thinking

**Goal:** Learn when to make the best local decision and when it fails.

### ğŸ’¡ Theory (From Problems)

- When greedy works perfectly (always picking the best choice)
- When greedy fails (and needs DP instead)

### âœ… Problems to Solve:

- Find the largest sum of non-adjacent numbers in an array
- Fractional Knapsack Problem
- Find the minimum number of coins to make X amount
- Find the maximum number of meetings in a single room
- Activity Selection Problem

ğŸš€ **Hard Enforcer:** "Job Scheduling with Deadlines"

---

## ğŸ§  Phase 5: Dynamic Programming (Start Thinking Like a Pro)

**Goal:** Train your brain to break problems into overlapping subproblems.

### ğŸ’¡ Theory (From Problems)

- Recognizing when DP is needed (brute force fails, greedy fails)
- How to break a problem into smaller ones
- Bottom-up vs. Top-down DP

### âœ… Problems to Solve:

- Fibonacci using DP (memoization & tabulation)
- Find the longest increasing subsequence in an array
- Find the number of ways to climb N stairs (1 or 2 steps at a time)
- Knapsack Problem (0/1 Knapsack)
- Partition an array into two subsets with equal sum

ğŸš€ **Hard Enforcer:** "Longest Palindromic Subsequence"

---

## ğŸŒ Phase 6: Graph Algorithms (Expand Your Thinking)

**Goal:** Master graph-based problems, which unlocks high-level CP.

### ğŸ’¡ Theory (From Problems)

- Graph representation (adjacency list vs. matrix)
- DFS & BFS traversal (when to use what)
- Shortest paths: Dijkstra vs. Bellman-Ford

### âœ… Problems to Solve:

- Find all connected components in an undirected graph (DFS/BFS)
- Check if a graph has a cycle
- Find the shortest path from A to B in an unweighted graph (BFS)
- Find the shortest path in a weighted graph (Dijkstraâ€™s Algorithm)
- Find a topological ordering of a graph

ğŸš€ **Hard Enforcer:** "Traveling Salesman Problem"

---

## ğŸ›£ Final Boss Stage: Solve Random Hard Problems

At this point, you should be able to tackle **ANY** standard algorithmic problem.

- CodeForces Div 2 C/D Problems
- Leetcode Hard Problems
- Google Kickstart/Meta Hacker Cup Past Problems

ğŸ”¥ **Once you survive this, you're ready to destroy CP.** ğŸ”¥

---

## ğŸ”„ How to Use This Roadmap

âœ… For each phase:

1. Learn just enough theory to solve one problem.
2. Solve that problem fully.
3. Use that problemâ€™s learnings to tackle harder problems.
4. Finish all easy problems before jumping to hard ones.
5. Push your brain to struggleâ€”never look at solutions unless stuck for hours.

This will force you to **think algorithmically** instead of just memorizing techniques.
