# 🚀 Algorithms Foundation

## 🔰 Phase 1: Pure Logic & Problem-Solving (No Algorithms Yet)

**Goal:** Develop pure problem-solving ability before touching any algorithms.

### 💡 Theory (Minimal)

- How to bruteforce properly (trying all possibilities smartly)
- Recognizing patterns & breaking problems into cases

### ✅ Problems to Solve:

- Two knights on a chessboard (count valid placements)
- Find the second smallest number in an array (without sorting)
- Find the most frequent number in an array (without sorting or maps)
- Reverse an integer without using strings
- Check if two strings are anagrams (without sorting or extra space)
- Find the first missing positive integer in an unsorted array

---

## 📍 Phase 2: Sorting & Searching (First Real Algorithms)

**Goal:** Master sorting and binary search—your first algorithmic tools.

### 💡 Theory (From Problems)

- Sorting logic: Why O(n log n) is the best we can do
- Binary search thinking: Searching not just for numbers but conditions

### ✅ Problems to Solve:

- Sorting a large array & finding duplicates (but without extra memory)
- Find the two numbers in an array that sum to x (sorted & unsorted cases)
- Search a number in a rotated sorted array
- Find the smallest missing number in a sorted array (without scanning linearly)
- Find the square root of a number without `sqrt()` (binary search on answer)

🚀 **Hard Enforcer:** "Painter’s Partition Problem"

---

## ⚡ Phase 3: Two Pointers & Sliding Window

**Goal:** Learn pointer-based problem solving to replace naive loops.

### 💡 Theory (From Problems)

- When to use two pointers instead of nested loops
- Sliding window to optimize sum & substring problems

### ✅ Problems to Solve:

- Find a pair in an array that sums to x (two-pointer approach)
- Longest substring without repeating characters (sliding window)
- Find the smallest subarray with sum ≥ S (sliding window)
- Sort an array of only 0s, 1s, and 2s in one pass
- Merge two sorted arrays without extra space

🚀 **Hard Enforcer:** "Trapping Rain Water"

---

## 🔥 Phase 4: Greedy Thinking

**Goal:** Learn when to make the best local decision and when it fails.

### 💡 Theory (From Problems)

- When greedy works perfectly (always picking the best choice)
- When greedy fails (and needs DP instead)

### ✅ Problems to Solve:

- Find the largest sum of non-adjacent numbers in an array
- Fractional Knapsack Problem
- Find the minimum number of coins to make X amount
- Find the maximum number of meetings in a single room
- Activity Selection Problem

🚀 **Hard Enforcer:** "Job Scheduling with Deadlines"

---

## 🧠 Phase 5: Dynamic Programming (Start Thinking Like a Pro)

**Goal:** Train your brain to break problems into overlapping subproblems.

### 💡 Theory (From Problems)

- Recognizing when DP is needed (brute force fails, greedy fails)
- How to break a problem into smaller ones
- Bottom-up vs. Top-down DP

### ✅ Problems to Solve:

- Fibonacci using DP (memoization & tabulation)
- Find the longest increasing subsequence in an array
- Find the number of ways to climb N stairs (1 or 2 steps at a time)
- Knapsack Problem (0/1 Knapsack)
- Partition an array into two subsets with equal sum

🚀 **Hard Enforcer:** "Longest Palindromic Subsequence"

---

## 🌍 Phase 6: Graph Algorithms (Expand Your Thinking)

**Goal:** Master graph-based problems, which unlocks high-level CP.

### 💡 Theory (From Problems)

- Graph representation (adjacency list vs. matrix)
- DFS & BFS traversal (when to use what)
- Shortest paths: Dijkstra vs. Bellman-Ford

### ✅ Problems to Solve:

- Find all connected components in an undirected graph (DFS/BFS)
- Check if a graph has a cycle
- Find the shortest path from A to B in an unweighted graph (BFS)
- Find the shortest path in a weighted graph (Dijkstra’s Algorithm)
- Find a topological ordering of a graph

🚀 **Hard Enforcer:** "Traveling Salesman Problem"

---

## 🛣 Final Boss Stage: Solve Random Hard Problems

At this point, you should be able to tackle **ANY** standard algorithmic problem.

- CodeForces Div 2 C/D Problems
- Leetcode Hard Problems
- Google Kickstart/Meta Hacker Cup Past Problems

🔥 **Once you survive this, you're ready to destroy CP.** 🔥

---

## 🔄 How to Use This Roadmap

✅ For each phase:

1. Learn just enough theory to solve one problem.
2. Solve that problem fully.
3. Use that problem’s learnings to tackle harder problems.
4. Finish all easy problems before jumping to hard ones.
5. Push your brain to struggle—never look at solutions unless stuck for hours.

This will force you to **think algorithmically** instead of just memorizing techniques.
